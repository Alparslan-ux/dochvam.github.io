[
  {
    "path": "SDMs/2022-01-31-intro-to-nimbleecology-site-occupancy-models/",
    "title": "Intro to nimbleEcology: site-occupancy models",
    "description": "An introductory guide to estimating site-occupancy models in a Bayesian or maximum likelihood framework.",
    "author": [
      {
        "name": "Ben R Goldstein",
        "url": {}
      }
    ],
    "date": "2022-01-31",
    "categories": [],
    "contents": "\r\n\r\nContents\r\nOveriview of the site-occupancy model\r\nStructure\r\n\r\nWhat is nimbleEcology?\r\nWhy should I use it?\r\n\r\nImplementing the occupancy model with nimbleEcology\r\nNext time…\r\nCitations and additional reading\r\n\r\nOveriview of the site-occupancy model\r\nIf you’re here for the nimbleEcology implementation, and feel comfortable with occupancy models, you can skip ahead to the next section.\r\nIn species distribuiton modeling, we’re often interested in whether animals’ presence on the landscape is influenced by or correlated with a spatiotemporal factor. For example, we might be interested in whether a species prefers dense or sparse tree cover, whether a species’ range is growing or declining over time, or whether a management strategy is actually working to\r\nSite-occupancy models are a type of statistical structure that allow us to ask these questions when our detection process is imperfect.\r\nStructure\r\nLet’s start by putting down some statistical equations for the simplest hierarchical site-occupancy model.\r\n\\[y_{ij} \\sim \\text{Bernoulli}(z_i * p_{ij})\\] \\[z_i \\sim \\text{Bernoulli}(\\psi_i)\\] \\[\\text{logit}(\\psi_{i}) = x_{i}^T\\beta\\] \\[\\text{logit}(p_{ij}) = w_{ij}^T\\gamma\\]\r\nwhere \\(i\\) and \\(j\\) index site and replicate visit, respectively; \\(y_{ij}\\) is a single detection or nondetection (1 or 0) at site \\(i\\), replicate \\(j\\); \\(z_i\\) is a latent state representing occupancy; \\(\\psi_i\\) is the probability that site \\(i\\) is occupied; \\(p_{ij}\\) is an observation-specific conditional detection probability; \\(x_i\\) and \\(w_{ij}\\) are vectors of covariates of interest; and \\(\\beta\\) and \\(\\gamma\\) are vectors of coefficients representing the effect of covariates on occupancy and detection, respectively.\r\nPhew. Let’s break that down.\r\nIn the first equation, we describe the probability distribution for our detection-nondetection observations, \\(y_{ij}\\). We say that each data point is Bernoulli-distributed: we have a probability of \\(z_i * p_{ij}\\) of seeing the animal. Since we either see it or we don’t, the probability of not seeing the animal is \\(1 - z_i * p_{ij}\\).\r\nIn the occupancy model, we assume that each “site” is in fact occupied or unoccupied, but that we can’t observe this condition perfectly. (I put “site” in quotation marks because the “site” need not be strictly spatial–for example, we could treat the occupancy status of a single location in different years as independent. Because the assumption that occupancy status doesn’t change is called “closure,” we can also call this unit a “unit of closure.”) In our second equation, we represent this with the latent state \\(z_i\\), which has a value of 1 if site \\(i\\) is occupied and 0 if it is not. If the site is unoccupied, we have no chance of seeing the animal. In that case, \\(z_i = 0\\) and the probability of \\(y_ij = 1\\) is also 0. Think of \\(z_i\\) as a switch that turns the probability of seeing the animal on or off. The “conditional probability of detection,” i.e. the probability that we see the animal when it’s present on a given observation, is \\(p_ij\\). It’s conditional because it only affects the data likelihood when \\(z_i =1\\). In the second equation, we define the distribution for the latent state \\(z_i\\), which has a probability of \\(\\psi_i\\).\r\nThe third equation links our probability of occupancy, \\(\\psi_i\\), to covariates. We say that, on the logit scale (which is a popular but arbitrary transformation from \\((-\\infty, \\infty)\\) to \\((0, 1)\\)), \\(\\psi_i\\) is a linear combination of some observed data describing our site, \\(x_{i}\\), with coefficients \\(\\beta\\). We want to estimate \\(\\beta\\) to get confidence or credible intervals on those effects.\r\nThe fourth equation replicates this logit-link structure for our detection probability, \\(p\\), and some covariates \\(w\\) with coefficients \\(\\gamma\\).\r\nThere are many other, much more comprehensive explanations of the occupancy model out there, including entire textbooks. I link some of these at the end of the post.\r\nWhat is nimbleEcology?\r\nnimbleEcology is an R package that makes it easier to implement some common ecological models in the general statistical software NIMBLE.\r\nThe package provides a series of distributions that you can use in NIMBLE models, similar to familiar distributions like dpois() or dbinom(). This will become clear with the example in this blog post, where I show how the entire occupancy hierarchical probability distribution for the occupancy model can be written with y ~ dOcc_v(...).\r\nWhy should I use it?\r\nLess risk of coding errors. We went ahead and implemented the occupancy distribution so you don’t have to. This saves lines of code and hopefully reduces some of the headache that inevitably comes from debugging a new model.\r\nIt’s easily modifiable. Implementing models in nimbleEcology, compared to something like unmarked, makes it easier to modify and customize your model when you’re ready to get fancy.\r\nIt’s fairly efficient. nimbleEcology uses marginalized distributions, saving memory and sometimes (but not always) increasing computational efficiency.\r\nSwap between MLE or Bayesian methodology. This maybe isn’t a need so much as an interesting feature, but with NIMBLE you have access to both maximum likelihood and Bayesian (MCMC) estimation with very few changes to the model code.\r\nImplementing the occupancy model with nimbleEcology\r\nSwift photo (c) J Tanner 2022. https://macaulaylibrary.org/asset/409111121In this section, I showcase the use of nimbleEcology for implementing an occupancy model with simulated data.\r\nLet’s say we have some data we collected in a study on how the occupancy of a bird, the white-throated swift. I have my detection/nondetection data in a matrix called “obs”. We surveyed 200 sites three times each, and recorded whether or not we observed swifts during those surveys.\r\nHere are the first six rows in the data:\r\n\r\n\r\nhead(obs)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    0    0    0\r\n[2,]    0    0    0\r\n[3,]    1    1    0\r\n[4,]    0    0    1\r\n[5,]    1    0    1\r\n[6,]    0    0    0\r\n\r\nWe detected the swift at four of the first six sites. Here are a few more summary statistics:\r\n\r\n\r\n# Total number of sites with detections (\"naive occupancy\")\r\nsum(rowSums(obs) > 0)\r\n\r\n\r\n[1] 69\r\n\r\n# Average number of observations per occupied site\r\nmean(obs[rowSums(obs) > 0, ])\r\n\r\n\r\n[1] 0.4879227\r\n\r\nWe want to know how the elevation and amount of forest cover impact the occupancy of our swifts in the study area. We measured elevation and forest cover at each of our sites. Here’s the first six sites’ data:\r\n\r\n\r\nhead(siteLevelData)\r\n\r\n\r\n   elevation forestCover\r\n1 -0.9559221  0.37841493\r\n2 -0.9790799 -0.01406795\r\n3  0.4368064  0.17601854\r\n4 -0.7193709 -0.92947860\r\n5 -0.2721558 -0.43107788\r\n6  0.0428613  0.49594396\r\n\r\n(In the previous section, each row of these data are an \\(x_i\\).)\r\nWe’re using an occupancy model because we think our data contains false negatives–i.e., sometimes we didn’t see a swift at an occupied site. We think that sometimes, high wind conditions could reduce our ability to see swifts. And we also don’t want to rule out the possibility that detection probabilities vary with elevation or tree cover. Disambiguating the effects of a single variable on both detection and probability is one of the main benefits of th occupancy model.\r\nHere’s data from the first six sites for our three detection variables.\r\n\r\n\r\nhead(obsLevelData[,,\"elevation\"])\r\n\r\n\r\n           [,1]       [,2]       [,3]\r\n[1,] -0.9559221 -0.9559221 -0.9559221\r\n[2,] -0.9790799 -0.9790799 -0.9790799\r\n[3,]  0.4368064  0.4368064  0.4368064\r\n[4,] -0.7193709 -0.7193709 -0.7193709\r\n[5,] -0.2721558 -0.2721558 -0.2721558\r\n[6,]  0.0428613  0.0428613  0.0428613\r\n\r\nhead(obsLevelData[,,\"forestCover\"])\r\n\r\n\r\n            [,1]        [,2]        [,3]\r\n[1,]  0.37841493  0.37841493  0.37841493\r\n[2,] -0.01406795 -0.01406795 -0.01406795\r\n[3,]  0.17601854  0.17601854  0.17601854\r\n[4,] -0.92947860 -0.92947860 -0.92947860\r\n[5,] -0.43107788 -0.43107788 -0.43107788\r\n[6,]  0.49594396  0.49594396  0.49594396\r\n\r\nhead(obsLevelData[,,\"windLevel\"])\r\n\r\n\r\n          [,1]       [,2]       [,3]\r\n[1,] 0.5818751  0.6126206 -0.7922553\r\n[2,] 0.2276861  0.7952973 -0.6619532\r\n[3,] 0.9545355 -0.6955473 -0.6014542\r\n[4,] 0.8137390  0.4535272  0.6110631\r\n[5,] 0.5897824 -0.3132945  0.1687786\r\n[6,] 0.3905541  0.3720862 -0.2839954\r\n\r\nFor the sake of simplicity, we’ll assume that our sites are random and representative of the study area, that we have good reason to believe we aren’t recording false positive observations, and that we don’t think our detection process is variable except due to the factors we’re considering (wind, forest cover, and elevation).\r\nLet’s get to modeling!\r\n\r\n\r\nlibrary(nimble)\r\nlibrary(nimbleEcology)\r\n\r\n\r\n\r\nFirst, to use NIMBLE, we’re going to define a nimbleCode object. This code object uses a pseudo-code language, blending .\r\nNIMBLE uses a declarative language, meaning order doesn’t matter. A consequence of this is that you can’t overwrite values. Instead of stepping through lines of code, think of nimbleCode as defining relationships between variables (nodes).\r\nFor a more in-depth overview of the NIMBLE code language\r\nOk, enough stalling. Here’s the NIMBLE code for our model, with comments.\r\n\r\n\r\noccuCode <- nimbleCode({\r\n  # Loop over sites\r\n  for (site in 1:nSites) {\r\n    # Here's the nimbleEcology magic: the dOcc_* distribution.\r\n    # This line of code says that our observations follow a probability\r\n    #   distribution in the occupancy model, with a single occupancy probability\r\n    #   and a vector of detection probabilities corresponding to each \r\n    #   observation. Note that we wass a whole site's worth of data at once.\r\n    # Try running ?nimbleEcology::dOcc in your R session for more info.\r\n    obs[site, 1:nReps] ~ dOcc_v(\r\n      probOcc = psi[site], \r\n      probDetect = p[site, 1:nReps],\r\n      len = nReps\r\n    )\r\n    \r\n    # We define a logit-linear relationship between \r\n    # inprod(x, y) is the same as x[1] * y[1] + x[2] * y[2] + ...\r\n    # Note that:\r\n    # - We can put logit() on the left-hand side like a model equation\r\n    # - The data intercept is represented in model matrix notation inside occuCovars\r\n    #   (more on that in a second)\r\n    # - We need EXPLICIT INDEXING for our vectors (beta[1:nBeta], not just beta).\r\n    #   This is an important difference between nimbleCode and base R\r\n    logit(psi[site]) <- inprod(occuCovars[site, 1:nBeta], beta[1:nBeta])\r\n    \r\n    # Loop over reps\r\n    for (rep in 1:nReps) {\r\n      # Do this again for each detection probability. Only difference is that\r\n      # p is now two-dimensional and detectionCovars is three-dimensional.\r\n      logit(p[site, rep]) <- inprod(detectionCovars[site, rep, 1:nGamma],\r\n                                    gamma[1:nGamma])\r\n    } # END reps loop\r\n  } # END site loop\r\n  \r\n  # Priors. We need these in order to do MCMC sampling. I'm going to choose some\r\n  # arbitrary, mostly uninformative priors.\r\n  # Priors on each covariate on occupancy:\r\n  for (i in 1:nBeta) {\r\n    beta[i] ~ dnorm(0, sd = 2.5)\r\n  }\r\n  # Priors on each covariate on detection:\r\n  for (i in 1:nGamma) {\r\n    gamma[i] ~ dnorm(0, sd = 2.5)\r\n  }\r\n})\r\n\r\n\r\n\r\nSome of this code might look unfamiliar to folks who have done Bayesian occupancy modeling before. I’ve gone out of my way to make things generalizable, using inprod() over, for example, intercept + elev[i] * b1 + forest[i] * b2. My motivation for doing this is that it’s super generalizable, and I’ll be able to add or remove covariates without making any changes to my code.\r\nNote that because we’re using nimbleEcology, we’ve “marginalized over” the latent state \\(z\\) and it’s not in the model. This is a good thing for a couple reasons: it reduces the amount of RAM needed, which can be important for large datasets; it slightly speeds up mixing time in some cases; and it saves some lines of code. However, there are often cases where we want \\(z\\), such as if we want a posterior distribution on the number of occupied sites. In that case we shouldn’t use nimbleEcology (but NIMBLE will do fine).\r\nThe next step in the NIMBLE workflow is to define a NIMBLE model object. This turns our code, which describes a series of nodes and the relationships between them, into an actual object composed of that structure.\r\nAll the data wrangling I have to do is just to get my inputs in the same form as I’ve described them.\r\nBecause I’m using inprod() I need to make sure my data have intercept columns first.\r\n\r\n\r\nsiteLevelData$intercept <- 1\r\nobsLevelData[,, \"intercept\"] <- 1\r\n\r\n\r\n\r\n\r\n\r\noccu_model <- nimbleModel(\r\n  code = occuCode,\r\n  constants = list(\r\n    nBeta = 3,\r\n    nGamma = 4,\r\n    nSites = nrow(obs),\r\n    nReps = ncol(obs)\r\n  ),\r\n  data = list(\r\n    obs = obs,\r\n    # I like indexing these here for two reasons: (1) I make sure they're going\r\n    #   into the model in order, and (2) \r\n    detectionCovars = \r\n      obsLevelData[,, c(\"intercept\", \"elevation\", \"forestCover\", \"windLevel\")],\r\n    occuCovars = siteLevelData[, c(\"intercept\", \"elevation\", \"forestCover\")]\r\n  ),\r\n  inits = list(\r\n    beta = rnorm(3),\r\n    gamma = rnorm(4)\r\n  )\r\n)\r\n\r\n\r\n\r\nThat’s it! We now have a nimbleModel object.\r\nOne of my favorite things about working in NIMBLE is that we can play with and query the nimbleModel.\r\n\r\n\r\n# Peek inside the model: what are the data values for the 22nd site?\r\noccu_model$obs[22,]\r\n\r\n\r\n[1] 0 0 0\r\n\r\n# What's the corresponding site-level data at this site?\r\noccu_model$occuCovars[22,] # Intercept, elevation, tree cover\r\n\r\n\r\n[1]  1.0000000  0.2463764 -0.1503483\r\n\r\n# What's the log-likelihood of the model given initial values?\r\n# (If this is non-NA, that means our model is initialized properly)\r\noccu_model$calculate()\r\n\r\n\r\n[1] -303.6887\r\n\r\nIf we wanted to, we could modify data or initial values at this stage, but not constants, which are “baked in” to the model when its built.\r\nI’ll go quickly over this next part, since using MCMC with NIMBLE is better explained elsewhere. Briefly, we’re going to build an MCMC object and then compile the whole thing so we’re ready to do some MCMC sampling.\r\n\r\n\r\nmcmc <- buildMCMC(occu_model)\r\n\r\n\r\n===== Monitors =====\r\nthin = 1: beta, gamma\r\n===== Samplers =====\r\nRW sampler (7)\r\n  - beta[]  (3 elements)\r\n  - gamma[]  (4 elements)\r\n\r\n# Compile to C++. This takes a second, but it's worth it!\r\ncomplist <- compileNimble(occu_model, mcmc)\r\n\r\n# We can still query / modify the compiled model\r\ncomplist$occu_model$obs[22,]\r\n\r\n\r\n[1] 0 0 0\r\n\r\nNow let’s do some MCMC sampling. 10,000 MCMC samples on 2 chains is a bit overkill for this model, but it’s quick–this takes about 20 seconds to run on my machine.\r\n\r\n\r\nsamples <- runMCMC(complist$mcmc, \r\n                   niter = 10000,\r\n                   nburnin = 1000,\r\n                   nchains = 2,\r\n                   thin = 1,\r\n                   samplesAsCodaMCMC = TRUE)\r\n\r\n\r\n|-------------|-------------|-------------|-------------|\r\n|-------------------------------------------------------|\r\n|-------------|-------------|-------------|-------------|\r\n|-------------------------------------------------------|\r\n\r\nWe can plot some of our chains to see how they mixed, for example the logit-scale effect of elevation on occupancy, which is beta[2] (because beta[1] is the intercept).\r\n\r\n\r\nplot(samples[, \"beta[2]\"])\r\n\r\n\r\n\r\n\r\nI like the package MCMCvis for MCMC summaries.\r\n\r\n\r\nsummary <- MCMCvis::MCMCsummary(samples)\r\n\r\nsummary$param <- c(\"Intercept (occu)\", \"Elev (occu)\", \"Forest (occu)\",\r\n                   \"Intercept (det)\", \"Elev (det)\", \"Forest (det)\", \"Wind (det)\")\r\n\r\nsummary[, c(\"param\", \"mean\", \"2.5%\", \"97.5%\")]\r\n\r\n\r\n                    param        mean       2.5%       97.5%\r\nbeta[1]  Intercept (occu)  0.27558912 -0.3995926  1.42759930\r\nbeta[2]       Elev (occu)  0.87816447 -0.4128858  2.23862643\r\nbeta[3]     Forest (occu) -1.82784288 -3.4780877 -0.62010363\r\ngamma[1]  Intercept (det) -0.81601934 -1.3094703 -0.35864626\r\ngamma[2]       Elev (det)  0.50585592 -0.1835229  1.26530091\r\ngamma[3]     Forest (det)  0.03689909 -0.7124781  0.69144787\r\ngamma[4]       Wind (det) -0.50269720 -0.9427505 -0.07756671\r\n\r\nWe found a negative effect of forest cover on occupancy, and a negative effect of wind speed on detection. Nice.\r\nNext time…\r\nStay tuned for two follow up posts. In the first, I’ll discuss easy ways to extend the occupancy model in NIMBLE to showcase the flexibility of this tool. Then, I’ll showcase an N-mixture model, and we’ll explore a case where marginalizing over a latent state can dramatically improve computation time.\r\nThanks for reading! Hit the “contact me” button at the top of the page if you have any questions or feedback.\r\nCitations and additional reading\r\nAll the code in this exercise is available in the Github repository for this blog, specifically here. Please feel free to download and play around with this .Rmd file, and to copy and use this code freely.\r\nRelevant papers and books:\r\nOriginal MacKenzie et al. 2002 paper on site-occupancy model\r\nPonisio et al. 2020 paper marginalizing distributions in NIMBLE\r\nOccupancy Estimation and Modeling textbook by MacKenzie et al.\r\nAs always, check out the NIMBLE User Manual and the NIMBLE examples page for more NIMBLE stuff.\r\n\r\n\r\n\r\n",
    "preview": "SDMs/2022-01-31-intro-to-nimbleecology-site-occupancy-models/intro-to-nimbleecology-site-occupancy-models_files/figure-html5/unnamed-chunk-13-1.png",
    "last_modified": "2022-02-04T11:33:39-08:00",
    "input_file": {}
  }
]
