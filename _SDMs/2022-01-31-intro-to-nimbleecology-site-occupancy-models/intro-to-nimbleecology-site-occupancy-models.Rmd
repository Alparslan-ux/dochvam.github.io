---
title: "Intro to nimbleEcology: site-occupancy models"
description: |
  An introductory guide to estimating site-occupancy models in a Bayesian or maximum likelihood framework.
author:
  - name: Ben R Goldstein
date: 2022-01-31
output:
  distill::distill_article:
    self_contained: false
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Overiview of the site-occupancy model

(If you're just here for the nimbleEcology implementation, and feel comfortable with occupancy models, you can skip ahead to the next section.)


In species distribuiton modeling, we're often interested in whether animals' presence on the landscape is influenced by or correlated with 

Occupancy models are used to 

In the occupancy model, we assume that each "site" is in fact occupied or unoccupied, but that we can't 

Why occupancy?

(I put "site" in quotation marks because the "site" need not be strictly spatial--for example, we could treat the occupancy status of a single location in different years as independent. Because the assumption that occupancy status doesn't change is called "closure," we can also call this unit a "unit of closure.")


### Structure

The dominant and simplest occupancy model

Let's start by putting down some statistical equations.

$$y_{ij} \sim \text{Bernoulli}(z_i * p_{ij})$$
$$z_i \sim \text{Bernoulli}(\psi_i)$$
$$\text{logit}(psi_{i}) = x_{ij}^T\beta$$
$$\text{logit}(p_{ij}) = w_{ij}^T\gamma$$


where $i$ and $j$ index site and replicate visit, respectively; $y_{ij}$ is a single detection or nondetection (1 or 0) at site $i$, replicate $j$; $z_i$ is a latent state 


Let's break that down.

In the first equation, we describe the probability distribution for our detection-nondetection observations, $y_{ij}$. We say that each data point is Bernoulli-distributed: we have a probability of $z_i * p_{ij}$ of seeing the animal. Since we either see it or we don't, the probability of not seeing the animal is $1 - z_i * p_{ij}$. 

The latent state is $z_i$, representing that site $i$ is either occupied or not. If the site is unoccupied, we have no chance of seeing the animal. In that case, $z_i = 0$ and the probability of $y_ij = 1$ is also 0. Think of $z_i$ as a switch that turns the probability of seeing the animal on or off. The "conditional probability of detection," i.e. the probability that we see the animal when it's present on a given observation, is $p_ij$. It's conditional because it only affects the data likelihood when $z_i =1$.

In the second equation, we define the distribution for the latent state $z_i$.

If this is confusing, there's a ton 



### Assumptions




# What is nimbleEcology?

### Why should I use it?


* It's easily modifiable
* It's fairly efficient
* We can easily use either MLE or Bayesian methodology

# Implementing the occupancy model with nimbleEcology

```{r echo = F, include = F}
# I use the R package "AHMbook" to quickly simulate some occupancy data

set.seed(8706)
dat <- AHMbook::simOcc(M = 200, J = 3, 
                       mean.occupancy = 0.5, 
                       beta1 = 0.75, 
                       beta2 = -1,
                       beta3 = 0,
                       mean.detection = 0.4, 
                       alpha1 = 0, 
                       alpha2 = -0.5,
                       alpha3 = 0,
                       time.effects = c(0,0),
                       sd.lp = 0,
                       b = 0,
                       show.plot = FALSE)

obs <- dat$y

siteLevelData <- data.frame(
  elevation = dat$elev,
  forestCover = dat$forest
)

obsLevelData <- array(
  data = NA,
  dim = c(200, 3, 4),
  dimnames = list(NULL, NULL, c("elevation", "forestCover", "windLevel", "intercept"))
)

obsLevelData[, , "elevation"] <- 
  matrix(siteLevelData$elevation, nrow = 200, ncol = 3)
obsLevelData[, , "forestCover"] <- 
  matrix(siteLevelData$forest, nrow = 200, ncol = 3)
obsLevelData[, , "windLevel"] <- dat$wind

```

In this section, I showcase the use of nimbleEcology for implementing an occupancy distribution 



Let's say we have some data we collected in a study on how the occupancy of a bird, the white-throated swift. I have my detection/nondetection data in a matrix called "obs". We surveyed 200 sites three times each, and recorded whether or not we observed swifts during those surveys.

Here are the first six rows in the data:

```{r}
head(obs)
```
We detected the swift at four of the first six sites. Here are a few more summary statistics:

```{r}
# Total number of sites with detections ("naive occupancy")
sum(rowSums(obs) > 0)

# Average number of observations per occupied site
mean(obs[rowSums(obs) > 0, ])
```


We want to know how the elevation and amount of forest cover impact the occupancy of our swifts in the study area. We measured elevation and forest cover at each of our sites. Here's the first six sites' data:

```{r}
head(siteLevelData)
```
(In the previous section, each row of these data are an $x_i$.)

We're using an occupancy model because we think our data contains false negatives--i.e., sometimes we didn't see a swift at an occupied site. We think that sometimes, high wind conditions could reduce our ability to see swifts. And we also don't want to rule out the possibility that detection probabilities vary with elevation or tree cover. Disambiguating the effects of a single variable on **both** detection and probability is one of the main benefits of th occupancy model.

Here's data from the first six sites for our three detection variables.

```{r}
head(obsLevelData[,,"elevation"])
head(obsLevelData[,,"forestCover"])
head(obsLevelData[,,"windLevel"])
```

For the sake of simplicity, we'll assume that our sites are random and representative of the study area, that we have good reason to believe we aren't recording false positive observations, and that we don't think our detection process is variable except due to the factors we're considering (wind, forest cover, and elevation).

Let's get to modeling!

```{r}
library(nimble)
library(nimbleEcology)
```


First, to use NIMBLE, we're going to define a `nimbleCode` object. This code object uses a pseudo-code language, blending .

NIMBLE uses a declarative language, meaning order doesn't matter. A consequence of this is that you can't overwrite values. Instead of stepping through lines of code, think of `nimbleCode` as defining relationships between variables (nodes).

For a more in-depth overview of the NIMBLE code language

Ok, enough stalling. Here's the NIMBLE code for our model, with comments.

```{r}

occuCode <- nimbleCode({
  # Loop over sites
  for (site in 1:nSites) {
    # Here's the nimbleEcology magic: the dOcc_* distribution.
    # This line of code says that our observations follow a probability
    #   distribution in the occupancy model, with a single occupancy probability
    #   and a vector of detection probabilities corresponding to each 
    #   observation. Note that we wass a whole site's worth of data at once.
    # Try running ?nimbleEcology::dOcc in your R session for more info.
    obs[site, 1:nReps] ~ dOcc_v(
      probOcc = psi[site], 
      probDetect = p[site, 1:nReps],
      len = nReps
    )
    
    # We define a logit-linear relationship between 
    # inprod(x, y) is the same as x[1] * y[1] + x[2] * y[2] + ...
    # Note that:
    # - We can put logit() on the left-hand side like a model equation
    # - The data intercept is represented in model matrix notation inside occuCovars
    #   (more on that in a second)
    # - We need EXPLICIT INDEXING for our vectors (beta[1:nBeta], not just beta).
    #   This is an important difference between nimbleCode and base R
    logit(psi[site]) <- inprod(occuCovars[site, 1:nBeta], beta[1:nBeta])
    
    # Loop over reps
    for (rep in 1:nReps) {
      # Do this again for each detection probability. Only difference is that
      # p is now two-dimensional and detectionCovars is three-dimensional.
      logit(p[site, rep]) <- inprod(detectionCovars[site, rep, 1:nGamma],
                                    gamma[1:nGamma])
    } # END reps loop
  } # END site loop
  
  # Priors. We need these in order to do MCMC sampling. I'm going to choose some
  # arbitrary, mostly uninformative priors.
  # Priors on each covariate on occupancy:
  for (i in 1:nBeta) {
    beta[i] ~ dnorm(0, sd = 2.5)
  }
  # Priors on each covariate on detection:
  for (i in 1:nGamma) {
    gamma[i] ~ dnorm(0, sd = 2.5)
  }
})

```

Some of this code might look unfamiliar to folks who have done Bayesian occupancy
modeling before. I've gone out of my way to make things generalizable, using
`inprod()` over, for example, `intercept + elev[i] * b1 + forest[i] * b2`.
My motivation for doing this is that it's super generalizable, and I'll be able
to add or remove covariates without making any changes to my code.

Note that because we're using nimbleEcology, we've "marginalized over" the latent
state $z$ and it's not in the model. This is a good thing for a couple reasons: it reduces the amount of RAM needed, which can be important for large datasets; it slightly speeds up mixing time in some cases; and it saves some lines of code. However, there are often cases where we **want** $z$, such as if we want a posterior distribution on the number of occupied sites. In that case we shouldn't use nimbleEcology (but NIMBLE will do fine).

The next step in the NIMBLE workflow is to define a NIMBLE model object. This turns
our code, which describes a series of nodes and the relationships between them, 
into an actual object composed of that structure.

All the data wrangling I have to do is just to get my inputs in the same
form as I've described them.

Because I'm using `inprod()` I need to make sure my data have intercept columns
first.

```{r}
siteLevelData$intercept <- 1
obsLevelData[,, "intercept"] <- 1
```


```{r}
occu_model <- nimbleModel(
  code = occuCode,
  constants = list(
    nBeta = 3,
    nGamma = 4,
    nSites = nrow(obs),
    nReps = ncol(obs)
  ),
  data = list(
    obs = obs,
    # I like indexing these here for two reasons: (1) I make sure they're going
    #   into the model in order, and (2) 
    detectionCovars = 
      obsLevelData[,, c("intercept", "elevation", "forestCover", "windLevel")],
    occuCovars = siteLevelData[, c("intercept", "elevation", "forestCover")]
  ),
  inits = list(
    beta = rnorm(3),
    gamma = rnorm(4)
  )
)
```

That's it! We now have a nimbleModel object.

One of my favorite things about working in NIMBLE is that we can play with and
query the nimbleModel.


```{r}
# Peek inside the model: what are the data values for the 22nd site?
occu_model$obs[22,]
# What's the corresponding site-level data at this site?
occu_model$occuCovars[22,] # Intercept, elevation, tree cover

# What's the log-likelihood of the model given initial values?
# (If this is non-NA, that means our model is initialized properly)
occu_model$calculate()

```
If we wanted to, we could modify data or initial values at this stage, but not constants, which are "baked in" to the model when its built.

I'll go quickly over this next part, since using MCMC with NIMBLE is better explained elsewhere. Briefly, we're going to build an MCMC object and then compile the whole thing so we're ready to do some MCMC sampling.

```{r}
mcmc <- buildMCMC(occu_model)

# Compile to C++. This takes a second, but it's worth it!
complist <- compileNimble(occu_model, mcmc)

# We can still query / modify the compiled model
complist$occu_model$obs[22,]
```


Now let's do some MCMC sampling. 10,000 MCMC samples on 2 chains is a bit overkill
for this model, but it's quick--this takes about 20 seconds to run on my machine.

```{r}
samples <- runMCMC(complist$mcmc, 
                   niter = 10000,
                   nburnin = 1000,
                   nchains = 2,
                   thin = 1,
                   samplesAsCodaMCMC = TRUE)
```

We can plot some of our chains to see how they mixed. Let's start with the effect of elevation on occupancy, which is `beta[2]` (because `beta[1]` is the intercept).

```{r}
plot(samples[, "beta[2]"])
```



I like the package `MCMCvis` for MCMC summaries.

```{r}
summary <- MCMCvis::MCMCsummary(samples)

summary$param <- c("Intercept (occu)", "Elev (occu)", "Forest (occu)",
                   "Intercept (det)", "Elev (det)", "Forest (det)", "Wind (det)")
```


We found a negative effect 


# Next time...

Stay tuned for two follow up posts. In the first, I'll discuss easy ways to extend
the occupancy model in NIMBLE to showcase the flexibility of this tool. Then,
I'll showcase an N-mixture model, and we'll explore a case where marginalizing
over a latent state can dramatically improve computation time.

Thanks for reading! Hit the "contact me" button at the top of the page if you 
have any questions or feedback.

# Citations and additional reading

All the code in this exercise is available in the Github repository for this blog, specifically here. Please feel free to download and play around with this .Rmd file, and to copy and use this code freely.

Relevant papers:

* Original Royle paper on occupancy
* Ponisio et al.
* Occupancy Estimation and Modeling book
* AHMIE book

As always, check out the NIMBLE User Manual and the NIMBLE examples page for more NIMBLE stuff.



